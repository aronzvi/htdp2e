;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname for-x-existing-abstractions) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
; for/and
; [X -> Y or false] [List-of X] -> Y or false
; applies f to all values of lox. returns false f results in false. otherwise, produces result of last call to f
(check-expect (and-map (lambda (i) (> (- 9 i) 0))(list 1 2 3 4 5 6 7 8 9))
              false)
(check-expect (and-map (lambda (i) (if (>= i 0) i false)) (list 1 2 3 4 5 6 7 8 9))
              9)

;(define (and-map f lox) false) ;stub

(define (and-map f lox)
  (local ((define res-list (map f lox)))
    (if (member? false res-list)
        false
        (first (reverse res-list)))))

; for/or
; [X -> Y or false] [List-of X] -> Y or false
; applies f to all values of lox. returns the first non false value if any. Otherwise return false
(check-expect (or-map (lambda (i) (if (= (- 9 i) 0) i false)) (list 1 2 3 4 5 6 7 8 9))
              9)
(check-expect (or-map (lambda (i) (if (< i 0) i false)) (list 1 2 3 4 5 6 7 8 9))
              false)

;(define (or-map f lox) false) ;stub

(define (or-map f lox)
  (local ((define res-list (map f lox))
          (define non-false (filter (lambda (x) (not (false? x))) res-list)))
    (if (empty? non-false)
        false
        (first non-false))))

; for/sum
; [X -> Number] [List-of X] -> Number
; adds up the numbers produced by applying f to every element of lox
(check-expect (for-sum (lambda (c) (string->int c)) (list "a" "b" "c"))
              294)

;(define (for-sum f lox) 0) ;stub

(define (for-sum f lox)
  (foldr + 0 (map f lox))) 

; for/product
; [X -> Number] [List-of X] -> Number
; multiplies the numbers produced by applying f to every element of lox
(check-expect (for-product (lambda (c) (+ (string->int c) 1)) (list "a" "b" "c"))
              970200)

;(define (for-product f lox) 0) ;stub

(define (for-product f lox)
  (foldr * 1 (map f lox))) 

; for/string
; [X -> 1String] [List-of X] -> String
; creates a String from the 1String sequences generated by f on each element of lox
(check-expect (for-string (lambda (n)
                            (local ((define a (string->int "a")))
                              (int->string (+ a n))))
                          (list 0 1 2 3 4 5 6 7 8 9))
              "abcdefghij")

;(define (for-string f lox) "") ;stub

(define (for-string f lox)
  (foldr string-append "" (map f lox)))


